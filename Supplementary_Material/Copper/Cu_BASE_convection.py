# Import packages
from dash import Dash, html, dcc, callback, ctx, Output, Input
from plotly.subplots import make_subplots
import plotly.graph_objs as go

import webbrowser
import json
import numpy as np
from copy import copy
from time import sleep
from tqdm import tqdm
import pandas as pd
from scipy.interpolate import interp1d

import wntr
import wntr.network.controls as controls

import pysimdeum

"""
FUNCTIONS
"""

"""
RETURNS: Same list of appliances given as parameter, but as objects created
by the built-in function of pySIMDEUM.
PARAMS:
    -my_appliances: List of strings containing the appliance types. These strings
    must match the appliance type names defined in pysimdeum.
"""
def get_appliances(my_appliances):
    obj_appliances = []
    my_appliances_del = copy(my_appliances)
    while len(my_appliances_del) > 0:
        #Build a house (family household)
        house = pysimdeum.built_house(house_type='family')
        house_appliances = house.appliances
        for appliance in house_appliances:
            for my_app in my_appliances_del:
                if appliance.name == my_app['type']:
                    obj_appliances.append(appliance)
                    my_appliances_del.remove(my_app)
    return obj_appliances
"""
RETURNS: 3D array containning the demand patterns generated by pySIMDEUM for 7
days (5 workdays + weekend). Each day is a column (last 2 are weekend) and
each 2D array within the 3D array corresponds with every appliance.
PARAMS:
    -appliances: List of appliance objects created by pySIMDEUM.
    -house: House object created by pySIMDEUM.
"""
def generate_weekly_patterns(appliances, house, random):
    pattern_list = {}
    if random:
        for j in range(7):
            if j >= 5:
                for user in house.users:
                    user.age = 'home_ad'
                    user.job = False
            else:
                for user in house.users:
                    user.age = 'work_ad' #change back later
                    user.job = True
                    #user.age = 'home_ad'
                    #user.job = False
            # Simulate water consumption for house (xarray.DataArray)
            consumption = house.simulate(num_patterns=1, duration='1 days')
            # Build statistics from consumption
            tot_cons_house = consumption.max(['user'])#TODO move demand if not enough appliances
            for i in range(len(appliances)):
                #pattern = tot_cons_house.data[:,i,:]
                appliance = appliances[i]['name']
                appliance_type = appliances[i]['type2']
                pattern = tot_cons_house.sel(enduse=appliance_type)
                if j == 0:
                    pattern_list[appliance] = pattern
                else:
                    pattern_list[appliance] = np.hstack((pattern_list[appliance], pattern))
    else:
        for appliance in appliances:
            name = appliance['name']
            junction = wn.get_node(name)
            for demand in junction.demand_timeseries_list:
                if demand.pattern is not None:
                    base_demand = demand.base_value
                    pattern_multipliers = demand.pattern.multipliers
                    adjusted_multipliers = []
                    time = 0
                    while time < duration:
                        for multiplier in pattern_multipliers:
                            adjusted_multipliers.append(multiplier * base_demand)
                        time = len(adjusted_multipliers) * time_step
                    array = np.zeros((1, len(adjusted_multipliers)))
                    array[0, :] = adjusted_multipliers
                    #time_list = list(range(0, duration + 1, time_step))
                    pattern_list[name] = array
                #else:
                    #pattern_list[name] = np.hstack((pattern_list[name], adjusted_multipliers))
                    
    return pattern_list
"""
RETURNS: String for time in clock format
PARAMS:
    -secs: Time in seconds
    -not_for_pattern: Boolean indicating if it will be used for labels only.
    The latter is to include the "day" if needed.
"""
def seconds_to_clock(secs, not_for_pattern):
    if not_for_pattern:
        days = int(np.floor(secs / (24 * 3600)))
    else:
        days = 0
    if days != 0:
        secs = secs - days * 24 * 3600
    hours = int(np.floor(secs / 3600))
    if hours != 0:
        secs = secs - hours * 3600
    minutes = int(np.floor(secs / 60))
    if minutes != 0:
        secs = secs - minutes * 60

    if hours < 10:
        hours = "0" + str(hours)
    else:
        hours = str(hours) 
    
    if minutes < 10:
        minutes = "0" + str(minutes)
    else:
        minutes = str(minutes)
        
    if secs < 10:
        secs = "0" + str(secs)
    else:
        secs = str(secs)
    
    if not_for_pattern:
        final_text = (hours + ':' + minutes + ':' + secs + ' (Day ' + str(days + 1) + ')')
    else:
        final_text = (hours + ':' + minutes + ':' + secs) #TODO
        
    return final_text
"""
RETURNS: Nothing. Draws 3D layout, scatter plot and line plot
    -data:
    -res_dic:
    -t:
    -opt:
"""
def draw_network_fig(data, res_dic, t, opt):
    
    #elem_to_plot_1 = opt['elem_to_plot_1']
    elem_to_plot_2 = opt['elem_to_plot_2']
    var_to_plot_1 = opt['var_to_plot_1'].lower()
    var_to_plot_2 = opt['var_to_plot_2'].lower()
    sim_to_plot_1 = opt['sim_to_plot_1']
    sim_to_plot_2 = opt['sim_to_plot_2']
    obj_to_plot_2 = opt['obj_to_plot_2']
    
    for result in res_dic:
        result['show2'] = False
        for sim in sim_to_plot_2:
            if result['legend'] == sim:
                result['show2'] = True
    
    for result in res_dic:
        
        res = result['results']
        link_temps = result['temperatures']['links']
        node_temps = result['temperatures']['nodes']
        
        link_cti = result['cti']['links']
        
        demands = res.node['demand']
        node_ages = res.node['quality']
    
        flows = res.link['flowrate']
        link_ages = res.link['quality']
    
        node_demands_at_time = round(demands.loc[t,:] * 1000 * 60, 2)
        node_ages_at_time = round(node_ages.loc[t,:] / 3600, 2)
    
        flow_at_time = flows.loc[t,:]
        link_ages_at_time = round(link_ages.loc[t,:] / 3600, 1)
        
        node_temps_at_time = node_temps[int(t / time_step)]
        link_temps_at_time = link_temps[int(t / time_step)]
    
        node_dics = data['nodes']
        link_dics = data['links']
    
        n_labels = []
        n_colors = []
        n_symbols = []
        n_sizes = []
        n_annotations = []
        
        n_plot = []
        n_plot_colors = []
        n_plot_symbols = []
        n_plot_sizes = []
        n_plot_annotations = []
        
        n_tanks = []
        
        Xn = []
        Yn = []
        Zn = []
    
        for node in node_dics:
            node_name = node['name']
            node_age = node_ages_at_time[node_name]
            node_temp = round(node_temps_at_time[node_name], 2)
            age_label = 'Age = ' + str(node_age) + ' hrs'
            temp_label = 'T = ' + str(node_temp) + ' °C'
            node_x = node['coordinates'][0]
            node_y = node['coordinates'][1]
            n_type = node['node_type']
            if n_type == 'Junction':
                node_z = node['elevation']
                b_demand = node['demand_timeseries_list'][0]['base_val']
                node_demand = demands.loc[t, node_name]
                #b_demand = str(round(b_demand / 0.0000630901964, 2)) + ' GPM'
                node_symbol = 'circle'
                if abs(b_demand) > 0:
                    n_plot.append(node_name)
                    node_demand_label = "q = " + str(round(node_demand * 1000 * 60, 2)) + ' L/min'
                    #node_label = node_demand_label + "<br>" + age_label
                    node_label = age_label + "<br>" + temp_label + "<br>" + node_demand_label
                    n_plot_annotations.append(node_label)
                    node_size = 5 + 2 / np.pi * np.arctan(node_age / 10) * 25 #TODO
                    #node_size = 12
                    if abs(round(node_demand * 1000 * 60, 2)) > 0:
                        if node_demand > 0:
                            node_color = 'blue'
                        else:
                            node_color = 'magenta'
                    else:
                        node_label = age_label + "<br>" + temp_label
                        node_color = 'cyan'
                    n_plot_colors.append(node_color)
                    n_plot_symbols.append(node_symbol)
                    n_plot_sizes.append(node_size)
                else:
                    node_color = 'lightgray'
                    node_size = 1
                    node_name = ''
                    node_label = ''
            elif n_type == 'Tank':
                n_plot.append(node_name)
                n_tanks.append(node_name)
                node_z = node['elevation']
                volume = np.pi * node['diameter'] ** 2 / 4 * node['max_level']
                #volume_label = 'V = ' + str(round(volume * 1000, 2)) + ' L'
                volume_label = 'V = ' + str(round(volume, 2)) + ' m³'
                #volume_label = 'V = ' + str(round(volume * 264.172, 2)) + ' gal'
                node_label = volume_label + "<br>" + age_label + "<br>" + temp_label
                n_plot_annotations.append(node_label)
                node_symbol = 'square'
                node_color = get_rgb(node_temp)
                #node_size = min(volume * 264.172 / 2, 50)
                node_size = 2 / np.pi * np.arctan(volume * 264.172 / 10) * 30
                n_plot_colors.append(node_color)
                n_plot_symbols.append(node_symbol)
                n_plot_sizes.append(5 + 2 / np.pi * np.arctan(node_age / 10) * 25)
            else:
                node_z = node['base_head']
                elevation_label = 'Elevation = ' + str(round(node['base_head'], 1)) + ' m'
                node_label = elevation_label + "<br>" + age_label + "<br>" + temp_label
                node_symbol = 'square'
                node_color = get_rgb(node_temp)
                node_size = 10
                
            node_annotation = dict(
                    showarrow=False,
                    x=node_x,
                    y=node_y,
                    z=node_z,
                    text=node_name,
                    xanchor="left",
                    xshift=10,
                    opacity=0.7)
                
            n_labels.append(node_label)
            n_symbols.append(node_symbol)
            n_colors.append(node_color)
            n_sizes.append(node_size)
            n_annotations.append(node_annotation)
            
            Xn.append(node_x)
            Yn.append(node_y)
            Zn.append(node_z)
 #------------------------------------------------ LINKS   
        l_names = []
        l_labels = []
        l_colors = []
        l_sizes = []
    
        Xe=[]
        Ye=[]
        Ze=[]
        
        for link in link_dics:
            link_name = link['name']
            link_age = link_ages_at_time[link_name]
            link_temp = round(link_temps_at_time[link_name], 2)
            age_label = 'Age = ' + str(link_age) + ' hrs'
            temp_label = 'T = ' + str(link_temp) + ' °C'
            initial = link['start_node_name']
            final = link['end_node_name']
            flow = round(flow_at_time[link['name']] * 1000 * 60, 2)
            link_color = get_rgb(link_temp)
                
            for node in node_dics:
                node_name = node['name']
                if node_name == initial:
                    link['x_start'] = node['coordinates'][0]
                    link['y_start'] = node['coordinates'][1]
                    if node['node_type'] == 'Reservoir':
                        link['z_start'] = node['base_head']
                    else:
                        link['z_start'] = node['elevation']
                elif node_name == final:
                    link['x_end'] = node['coordinates'][0]
                    link['y_end'] = node['coordinates'][1]
                    if node['node_type'] == 'Reservoir':
                        link['z_end'] = node['base_head']
                    else:
                        link['z_end'] = node['elevation']
         
            Xe.append([link['x_start'], link['x_end'], None])
            Ye.append([link['y_start'], link['y_end'], None])
            Ze.append([link['z_start'], link['z_end'], None])
            
            l_diameter = link['diameter']
            l_diameter_in = round(l_diameter * 39.3701, 1)
            link_lable = 'd = ' + str(l_diameter_in) + '"<br>' + age_label + '<br>' + temp_label
            #link_size = l_diameter_in * 2
            link_size = 5
            
            l_names.append(link_name)
            l_labels.append(link_lable)
            l_colors.append(link_color)
            l_sizes.append(link_size)
        
        Xe = np.array(Xe)
        Ye = np.array(Ye)
        Ze = np.array(Ze)
        
        #--------------------------------------MAXES
        
        all_times = []
        include_days = True
        for i in range(len(node_ages)):
            all_times.append(seconds_to_clock(i*time_step, include_days))
        
        max_ages = []
        max_demands = []
        max_temps = []
        max_sizes = []
        max_labels = []
        for node in n_plot:
            all_ages = round(node_ages.loc[:,node] / 3600, 1)
            max_age = round(max(all_ages), 1)
            max_ages.append(max_age)
            all_demands = round(demands.loc[:,node] * 1000 * 60, 2)
            max_demand = round(max(all_demands), 2)
            max_demands.append(max_demand)
            
            max_sizes.append(5 + 2 / np.pi * np.arctan(max_age / 10) * 25)
            
            if var_to_plot_1 == 'age':
                max_time = all_ages.idxmax()
                max_time = seconds_to_clock(max_time, include_days)
                max_labels.append('Max. age = ' + str(max_age) + ' hrs<br> At time = ' + max_time)
            elif var_to_plot_1 == 'demand':
                max_time = all_demands.idxmax()
                max_time = seconds_to_clock(max_time, include_days)
                max_labels.append('Max. demand = ' + str(max_demand) + ' L/min<br> At time = ' + max_time)
            
        if not('fig1' in locals()):
            
            axis=dict(showbackground=False, showline=False, zeroline=False, showgrid=False, showticklabels=False, title='')
            
            layout = go.Layout(
                     uirevision='true',
                     height=600,
                     showlegend=False,
                     scene=dict(
                         xaxis=dict(axis),
                         yaxis=dict(axis),
                         zaxis=dict(axis),
                         annotations=n_annotations
                    ))
            
            fig1 = make_subplots(rows=1, cols=2,
                                column_widths=[0.4, 0.6],
                                row_heights=[1],
                                specs=[[{'type': 'scene'}, {'type': 'xy'}]])
            
            fig1.update_layout(layout)
            
        if result['legend'] == sim_to_plot_1:
            
#----------------------------------------- 3D scatter
    
            L = len(link_dics)
            for i in range(L):
                fig1.add_trace(go.Scatter3d(x=[Xe[i,0], Xe[i,1]], y=[Ye[i,0], Ye[i,1]], z=[Ze[i,0], Ze[i,1]], name = l_names[i], mode='lines', line=dict(color=l_colors[i], width=l_sizes[i]), hoverinfo='text', text=l_labels[i]),
                              row=1, col=1)
            
            fig1.add_trace(go.Scatter3d(x=Xn, y=Yn, z=Zn, mode='markers', name='nodes',
                               marker=dict(symbol=n_symbols, size=n_sizes, color=n_colors, colorscale='Viridis', 
                                  line=dict(color='rgb(50,50,50)', width=0.5)), text=n_labels, hoverinfo='text'),
                          row=1, col=1)
            
#------------------------------------------ normal scatter
            
            if var_to_plot_1 == 'age':
                var_plot = node_ages_at_time[n_plot]
                max_var = max_ages
            elif var_to_plot_1 == 'demand':
                var_plot = node_demands_at_time[n_plot]
                max_var = max_demands
            
            fig1.add_trace(
                go.Scatter(x=n_plot, y=var_plot, mode='markers',
                           marker=dict(symbol=n_plot_symbols, size=n_plot_sizes, color=n_plot_colors, colorscale='Viridis',
                                       line=dict(color='rgb(50,50,50)', width=0.5)), text=n_plot_annotations, hoverinfo='text'),
                row=1, col=2,)
            
            fig1.add_trace(
                go.Scatter(x=n_plot, y=max_var, mode='markers',
                           marker=dict(symbol=n_plot_symbols, size=max_sizes, color='lightgray', colorscale='Viridis',
                                       line=dict(color='rgb(50,50,50)', width=0.5)), text=max_labels, hoverinfo='text'),
                row=1, col=2,)
            
            age_range = [0, int(np.ceil(max(max_var))) + 5]
            fig1.update_layout(yaxis_range=age_range)
        
#------------------------------------------ line plot
        
        sum_ages = round(node_ages.loc[:, n_plot].sum(axis = 1) / 3600, 1)
        common = set(n_plot).intersection(set(n_tanks))
        n_plot_no_tanks = [k for k in n_plot if k not in common]
        total_demand = round(demands.loc[:, n_plot_no_tanks].sum(axis = 1) * 1000 * 60, 2)
        
        if elem_to_plot_2 == 'Node':
            if var_to_plot_2 == 'age':
                y_axis = 'AGE (HOURS)'
                title1 = 'age'
                if obj_to_plot_2 == 'SUM OF ALL':
                    line_plot = sum_ages
                    title2 = 'the sum of all appliance nodes and tanks'
                else:
                    line_plot = round(node_ages.loc[:, obj_to_plot_2] / 3600, 1)
                    title2 = 'node ' + obj_to_plot_2
            elif var_to_plot_2 == 'demand':
                title1 = 'demand'
                y_axis = 'DEMAND (LPM)'
                if obj_to_plot_2 == 'SUM OF ALL':
                    line_plot = total_demand
                    title2 = 'the sum of all appliance nodes'
                else:
                    line_plot = round(demands.loc[:, obj_to_plot_2] * 1000 * 60, 2)
                    title2 = 'node ' + obj_to_plot_2
        elif elem_to_plot_2 == 'Link':
            if var_to_plot_2 == 'age':
                y_axis = 'AGE (HOURS)'
                title1 = 'age'
                line_plot = round(link_ages.loc[:, obj_to_plot_2] / 3600, 1)
            elif var_to_plot_2 == 'temperature':
                y_axis = 'TEMP. (°C)'
                title1 = 'temperature'
                new_link_temps = [round(d[obj_to_plot_2], 1) for d in link_temps]
                line_plot = new_link_temps
            elif var_to_plot_2 == cti_option_text.lower():
                y_axis = 'CTI ' + str(low_interval_temp) + '-' + str(high_interval_temp) + '°C ' +' (hours)'
                title1 = 'time between ' + str(low_interval_temp) + '°C and ' + str(high_interval_temp) + '°C'
                new_link_cti = [round(d[obj_to_plot_2], 1) for d in link_cti]
                line_plot = new_link_cti
            title2 = 'link ' + obj_to_plot_2
        
        if not('fig2' in locals()):
            fig2 = go.Figure()
            fig2.update_layout(
                title='Showing ' + title1 + ' for ' + title2,
                xaxis_title='SIMULATION TIME',
                yaxis_title=y_axis,
                legend_title="Simulation with:",
                font=dict(
                    family="Courier New, monospace",
                    size=10,
                    color="RebeccaPurple"
                )
            )
        
        if result['show2']:
            fig2.add_trace(go.Scatter(
                x=all_times,
                y=line_plot,
                name=result['legend'],
                mode='lines',
                uirevision='true'
            ))
            
    if var_to_plot_2 == 'temperature':
        fig2.add_trace(go.Scatter(
            x=all_times,
            y=[high_interval_temp] * len(all_times),
            name=str(high_interval_temp) + '°C',
            mode='lines',
            line=dict(dash='dash'),
            uirevision='true'
        ))
        fig2.add_trace(go.Scatter(
            x=all_times,
            y=[low_interval_temp] * len(all_times),
            name=str(low_interval_temp) + '°C',
            mode='lines',
            line=dict(dash='dash'),
            uirevision='true'
        ))
    
    return [fig1, fig2]

def get_network_data(wn):
    wntr.network.write_json(wn, 'House1.json')
    data = []
    with open('House1.json') as json_data:
        data = json.load(json_data)
        json_data.close()
    return data

def get_plot_time_marks(slider_range):
    # mark_interval = 0
    # if slider_range / 3600 <= 24:
    #     mark_interval = 3600
    # elif slider_range / (3600*2) <= 30:
    #     mark_interval = 3600*2
    # elif slider_range / (3600*3) <= 30:
    #     mark_interval = 3600*3
    # elif slider_range / (3600*4) <= 30:
    #     mark_interval = 3600*4
    # elif slider_range / (3600*6) <= 30:
    #     mark_interval = 3600*6
    # elif slider_range / (3600*12) <= 30:
    #     mark_interval = 3600*12
    # else:
    #     mark_interval = 3600*24
    
    mark_interval = 3600 * 2 #TODO

    mark_dic = {}
    total_marks = int(np.floor(slider_range / mark_interval)) + 1
    for i in range(total_marks):
        mark_value = i * mark_interval
        if mark_value < 10:
            mark_label = '0' + str(int(mark_value / 3600))
        else:
            mark_label = str(int(mark_value / 3600))
        mark_label = mark_label + ':00'
        #mark_label = seconds_to_clock(mark_value, False)
        label_dic = {'label': mark_label}
        mark_dic.update({mark_value : label_dic})
    return mark_dic

def get_temp_dics(results_dic, data): #TODO here are the global pipe, wall and insulator properties, for now
    for result in results_dic:
        res = result['results']
        
        demands = res.node['demand']
        flows = res.link['flowrate']
        
        for name, node in wn.nodes():
            node.links = []
            node.temperature = 0
            node.cti = 0
            
        for name, link in wn.pipes():
            t_room, k_pipe, e_pipe, k_insulator, e_insulator, k_wall, z_wall, is_insulated, has_wall = get_pipe_properties(name)
            link.temperature_infinity = t_room
            link.temperature = link.temperature_infinity
            link.temperature_s_in = link.temperature_infinity
            link.temperature_s_ex = link.temperature_infinity
            link.temperature_s_ex_air = link.temperature_infinity
            link.cti = 0
            link.flow_direction = 0
            link.start_node_packages = link.start_node_name
            #if link.link_type == 'Pipe':
            link.volume = link.length * np.pi * link.diameter ** 2 / 4
            link.insulator = is_insulated #Not insulated if False
            link.wall = has_wall #No wall if False
            link.k_insulator = k_insulator
            link.k_wall = k_wall
            link.k_pipe = k_pipe #PEX 0.33-0.50 #Cu 400
            link.z_wall = z_wall
            link.e_link = e_pipe #PEX 1.2-2.5mm #Cu 1.2-2.4mm
            link.e_insulator = e_insulator
            start_node = wn.get_node(link.start_node_name)
            x_start, y_start = start_node.coordinates
            start_node.links.append(name)
            end_node = wn.get_node(link.end_node_name)
            x_end, y_end = end_node.coordinates
            end_node.links.append(name)
            if start_node.node_type == 'Reservoir':
                z_start = start_node.base_head
            else:
                z_start = start_node.elevation
            if end_node.node_type == 'Reservoir':
                z_end = end_node.base_head
            else:
                z_end = end_node.elevation
            delta_xy = ((x_end - x_start) ** 2 + (y_end - y_start) ** 2) ** (1 / 2)
            delta_z = abs(z_end - z_start)
            if delta_xy == 0:
                theta = np.pi / 2
            else:
                theta = np.arctan(delta_z / delta_xy)
            link.theta = theta
            theta_critical = np.arctan(link.diameter / link.length)
            if theta <= theta_critical:
                link.high_node = [None]
            elif z_end > z_start:
                link.high_node = [link.end_node_name]
            else:
                link.high_node = [link.start_node_name]
            link.packages = [{'volume': link.volume, 'temperature': link.temperature_infinity, 'temperature_s_in': link.temperature_infinity, 'temperature_s_ex': link.temperature_infinity, 'temperature_s_ex_air': link.temperature_infinity, 'old_pipe': link.name}]
        
        for i in range(2):
            for name, link in wn.valves():
                t_room, k_pipe, e_pipe, k_insulator, e_insulator, k_wall, z_wall, is_insulated, has_wall = get_pipe_properties(name)
                link.temperature_infinity = t_room #maybe not necessary
                link.temperature = link.temperature_infinity #maybe not necessary
                link.temperature_s_in = link.temperature_infinity #maybe not necessary
                link.temperature_s_ex = link.temperature_infinity #maybe not necessary
                link.cti = 0 #maybe not necessary
                link.flow_direction = 0 #maybe not necessary #TODO
                start_node = wn.get_node(link.start_node_name)
                links_of_start = start_node.links
                end_node = wn.get_node(link.end_node_name)
                links_of_end = end_node.links
                start_name = link.start_node_name
                end_name = link.end_node_name
                for pipe_name in links_of_start: #for all pipes that connect to the valve from the start
                    pipe = wn.get_link(pipe_name)
                    high_nodes = pipe.high_node
                    if (start_name in high_nodes) and (end_name not in high_nodes): #if the valve start node is the high node of that pipe
                        pipe.high_node += [end_name] #then the end node of the valve must also be its high node
                    if pipe_name not in links_of_end:
                        end_node.links.append(pipe_name) #all the start node links are also links of the end node
                for pipe_name in links_of_end: #for all pipes that connect to the valve from the end
                    pipe = wn.get_link(pipe_name)
                    high_nodes = pipe.high_node
                    if end_name in high_nodes: #if the valve end node is the high node of that pipe
                        pipe.high_node += [start_name] #then the start node of the valve must also be its high node
                    if pipe_name not in links_of_start:
                        start_node.links.append(pipe_name) #all the end node links are also links of the start node
                
        temp_dics = {'links': [],'links_s_ex': [], 'nodes': []}
        cti_dics = {'links': [], 'nodes': []}
        for t in tqdm(range(int(duration / time_step + 1))):
            sleep(0.0001)
            #Add demand to the total outflow count of each demand node
            for name, node in wn.nodes():
                node.volume = 0
                node.sum_count = 0
                node.links_out = []
                node.links_in = 0
                node.links_check = 0
                if node.node_type == 'Junction':
                    node.outflow = round(demands.loc[t * time_step, name], 6)
                else:
                    node.outflow = 0
                    
            for name, link in wn.links():
                start_node = wn.get_node(link.start_node_name)
                end_node = wn.get_node(link.end_node_name)
                link_flow = round(flows.loc[t * time_step, name], 6)
                if link_flow < 0:
                    new_direction = -1
                    start_node.links_in += 1
                    start_node.links_check += 1
                    end_node.links_out.append(name)
                    end_node.outflow += abs(link_flow)
                    link.start_node_packages = end_node.name
                elif link_flow > 0:
                    new_direction = 1
                    end_node.links_in += 1
                    end_node.links_check += 1
                    start_node.links_out.append(name)
                    start_node.outflow += link_flow
                    link.start_node_packages = start_node.name
                else:
                    new_direction = 0
                #Update temperatures of all packages
                if link.link_type == 'Pipe':
                    #Merge packages if no flow
                    if new_direction == 0:
                        temp_vol = 0
                        temp_vol_s_in = 0
                        temp_vol_s_ex = 0
                        temp_vol_s_ex_air = 0
                        for package in link.packages:
                            temp_vol += package['temperature'] * package['volume']
                            temp_vol_s_in += package['temperature_s_in'] * package['volume']
                            temp_vol_s_ex += package['temperature_s_ex'] * package['volume']
                            temp_vol_s_ex_air += package['temperature_s_ex_air'] * package['volume']
                        link.temperature = temp_vol / link.volume
                        link.temperature_s_in = temp_vol_s_in / link.volume
                        link.temperature_s_ex = temp_vol_s_ex / link.volume
                        link.temperature_s_ex_air = temp_vol_s_ex_air / link.volume
                        t_bulk = link.temperature
                        t_s_in = link.temperature_s_in
                        t_s_ex = link.temperature_s_ex
                        t_s_ex_air = link.temperature_s_ex_air

                        link.packages = [{'temperature': t_bulk, 'volume': link.volume, 'temperature_s_in': t_s_in, 'temperature_s_ex': t_s_ex, 'temperature_s_ex_air': t_s_ex_air, 'old_pipe': link.name}]
                        start_node.temperature = (start_node.temperature * start_node.sum_count + t_bulk) / (start_node.sum_count + 1)
                        start_node.sum_count += 1
                        end_node.temperature = (end_node.temperature * end_node.sum_count + t_bulk) / (end_node.sum_count + 1)
                        end_node.sum_count += 1
                    #reverse package order if flow changes to opposite direction
                    elif new_direction != link.flow_direction:
                        link.packages.reverse()
                    #Function that updates the temperature of a link
                    #update_pipe_temperature(link, abs(link_flow)) #TODO
                    update_pipe_temperature(link, flows, t)
                        
                link.flow_direction = new_direction
                    
            for name, reservoir in wn.reservoirs():
                reservoir.temperature = cold_water
                if reservoir.outflow != 0:
                    vol_new = reservoir.outflow * time_step
                    temp_new = cold_water
                    car = [{'volume': vol_new, 'temperature': temp_new, 'temperature_s_in': temp_new, 'temperature_s_ex': temp_new, 'temperature_s_ex_air': temp_new, 'old_pipe': 'COLD_SOURCE'}] #TODO name from file
                    move_packages(name, car, flows, t)
                    
            for name, tank in wn.tanks():
                tank.temperature = hot_water
                if tank.outflow != 0:
                    vol_new = tank.outflow * time_step
                    temp_new = hot_water
                    car = [{'volume': vol_new, 'temperature': temp_new, 'temperature_s_in': temp_new, 'temperature_s_ex': temp_new, 'temperature_s_ex_air': temp_new, 'old_pipe': 'HWH'}] #TODO change name from file
                    move_packages(name, car, flows, t)
            
            for name, valve in wn.valves():
                start_node = wn.get_node(valve.start_node_name)
                valve.temperature = start_node.temperature
                    
            for name, pump in wn.pumps():
                start_node = wn.get_node(pump.start_node_name)
                pump.temperature = start_node.temperature
                
            node_temps = {}
            link_temps = {}
            link_temps_s_ex = {}
            node_cti = {}
            link_cti = {}
            for name, link in wn.links(): #TODO: Check if valves not needed
                link_temps[name] = link.temperature
                link_temps_s_ex[name] = link.temperature_s_ex
                if t > 0:
                    if link.temperature >= low_interval_temp and link.temperature <= high_interval_temp:
                        link.cti = link.cti + time_step / 3600
                    else:
                        link.cti = 0
                link_cti[name] = link.cti
                start = link.start_node_name
                end = link.end_node_name
                if not(start in node_temps.keys()):
                    start_node = wn.get_node(start)
                    node_temps[start] = start_node.temperature
                    if t > 0:
                        if start_node.temperature >= low_interval_temp and start_node.temperature <= high_interval_temp:
                            start_node.cti = start_node.cti + time_step / 3600
                        else:
                            start_node.cti = 0
                    node_cti[name] = start_node.cti
                if not(end in node_temps.keys()):
                    end_node = wn.get_node(end)
                    node_temps[end] = end_node.temperature
                    if t > 0:
                        if end_node.temperature >= low_interval_temp and end_node.temperature <= high_interval_temp:
                            end_node.cti = end_node.cti + time_step / 3600
                        else:
                            end_node.cti = 0
                    node_cti[name] = end_node.cti
                    
            temp_dics['links'].append(link_temps)
            temp_dics['links_s_ex'].append(link_temps_s_ex)
            temp_dics['nodes'].append(node_temps)
            cti_dics['links'].append(link_cti)
            cti_dics['nodes'].append(node_cti)
        
        result['temperatures'] = temp_dics
        result['cti'] = cti_dics
        
    return results_dic

def move_packages(start_node_name, car, flows, t):
    node = wn.get_node(start_node_name)
    node.temperature = car[0]['temperature']
    node.volume = 0
    if len(node.links_out) > 0:
        for link_name in node.links_out:
            link = wn.get_link(link_name)
            link_flow = round(flows.loc[t * time_step, link_name], 6)
            weight = abs(link_flow) / node.outflow
            sub_car = []
            for package in car:
                p_vol = package['volume'] * weight
                p_temp = package['temperature']
                p_temp_s_in = package['temperature_s_in']
                p_temp_s_ex = package['temperature_s_ex']
                p_temp_s_ex_air = package['temperature_s_ex_air']
                p_old_pipe = package['old_pipe']
                sub_car.append({'volume': p_vol, 'temperature': p_temp, 'temperature_s_in': p_temp_s_in, 'temperature_s_ex': p_temp_s_ex, 'temperature_s_ex_air': p_temp_s_ex_air, 'old_pipe': p_old_pipe})
            if link.link_type == 'Pipe':
                for p in link.packages:
                    sub_car.append(p)
                link.packages = []
                av_volume = link.volume
                temp_vol = 0
                temp_vol_s_in = 0
                temp_vol_s_ex = 0
                temp_vol_s_ex_air = 0
                while av_volume > 0:
                    package = sub_car[0]
                    p_vol = package['volume']
                    p_temp = package['temperature']
                    p_temp_s_in = package['temperature_s_in']
                    p_temp_s_ex = package['temperature_s_ex']
                    p_temp_s_ex_air = package['temperature_s_ex_air']
                    p_old_pipe = package['old_pipe']
                    if p_old_pipe != link.name:
                        t_bulk = p_temp
                        t_room = link.temperature_infinity
                        t_arit_mean = (t_bulk + t_room) / 2
                        t_geom_mean = (t_bulk * t_room) ** 0.5                          
                        if t_bulk >= t_room: #if cooling
                            t_s_in = t_arit_mean
                            t_s_ex = t_geom_mean
                        else: #heating
                            t_s_in = t_geom_mean
                            t_s_ex = t_arit_mean
                        package['temperature_s_in'] = t_s_in
                        package['temperature_s_ex'] = t_s_ex
                        package['temperature_s_ex_air'] = t_s_ex
                        package['old_pipe'] = link.name
                    if p_vol < av_volume:
                        link.packages.append(package)
                        sub_car.remove(package)
                        temp_vol += p_temp * p_vol
                        temp_vol_s_in += p_temp_s_in * p_vol
                        temp_vol_s_ex += p_temp_s_ex * p_vol
                        temp_vol_s_ex_air += p_temp_s_ex_air * p_vol
                        av_volume = av_volume - p_vol
                    else:
                        link.packages.append({'volume': av_volume, 'temperature': p_temp, 'temperature_s_in': p_temp_s_in, 'temperature_s_ex': p_temp_s_ex, 'temperature_s_ex_air': p_temp_s_ex_air, 'old_pipe': p_old_pipe})
                        sub_car[0]['volume'] = p_vol - av_volume
                        temp_vol += p_temp * av_volume
                        temp_vol_s_in += p_temp_s_in * av_volume
                        temp_vol_s_ex += p_temp_s_ex * av_volume
                        temp_vol_s_ex_air += p_temp_s_ex_air * av_volume
                        link.temperature = temp_vol / link.volume
                        link.temperature_s_in = temp_vol_s_in / link.volume
                        link.temperature_s_ex = temp_vol_s_ex / link.volume
                        link.temperature_e_ex_air = temp_vol_s_ex_air / link.volume
                        av_volume = 0
                
            if link.end_node_name == name:
                end_node = wn.get_node(link.start_node_name)
            else:
                end_node = wn.get_node(link.end_node_name)
                
            if end_node.node_type == 'Junction':
                end_node.links_check = end_node.links_check - 1
                if end_node.links_in != 1:
                    for package in sub_car:
                        p_vol = package['volume']
                        p_temp = package['temperature']
                        p_temp_s_in = package['temperature_s_in']
                        p_temp_s_ex = package['temperature_s_ex']
                        p_temp_s_ex_air = package['temperature_s_ex_air']
                        p_old_pipe = package['old_pipe']
                        end_node.temperature = (end_node.temperature * end_node.volume + p_temp * p_vol) / (end_node.volume + p_vol)
                        end_node.volume += p_vol
                    sub_car = [{'volume': end_node.volume, 'temperature': end_node.temperature, 'temperature_s_in': p_temp_s_in, 'temperature_s_ex': p_temp_s_ex, 'temperature_s_ex_air': p_temp_s_ex_air, 'old_pipe': p_old_pipe}]
                if end_node.links_check == 0:
                    move_packages(end_node.name, sub_car, flows, t)

def update_pipe_temperature(link, flows, t): #TODO: create separate functions for axial
    name = link.name
    start_node_name = link.start_node_name
    start_node = wn.get_node(start_node_name)
    start_links = start_node.links
    end_node_name = link.end_node_name
    end_node = wn.get_node(end_node_name)
    end_links = end_node.links
    flow = abs(round(flows.loc[t * time_step, name], 6))
    t_room = link.temperature_infinity
    if name.startswith('HWH'):
        link.packages = [{'volume': link.volume, 'temperature': t_room, 'temperature_s_in': t_room, 'temperature_s_ex': t_room, 'temperature_s_ex_air': t_room, 'old_pipe': name}]
    else:
        d = link.diameter
        A_cross = np.pi * d ** 2 / 4
        v_cross = flow / A_cross
        theta = link.theta
        high_node = link.high_node
            
        link_packages = link.packages
        
        for i, package in enumerate(link_packages):
            package_volume = package['volume']
            package_length = package_volume / A_cross
            #-----Radial
            R_overall, R_water, R_pipe, R_insulator, R_wall, R_air = get_R(link, package, flow)
            
            t_bulk = package['temperature']
            
            rho_water = get_property(t_bulk, 'w_rho')
            cp_water = get_property(t_bulk, 'w_cp')
            b = 1 / (rho_water * package_volume* cp_water * R_overall)
            
            dt_r = t_room + (t_bulk - t_room) * np.e ** (-b * time_step) - t_bulk
            
            axial = True
            dt_a_conduction = 0
            dt_a_convection = 0
            if axial == True:
                #-----Axial
                dt_a_conduction = 0
                dt_a_convection = 0
                
                mu_water = get_property(t_bulk, 'w_mu')
                nu_water = mu_water / rho_water
                beta_water = get_property(t_bulk, 'w_beta')
                Re_water = v_cross * d / nu_water
                k_water = get_property(t_bulk, 'w_k')
                R_0 = package_length / 2 / (k_water * A_cross)
                if theta < np.pi / 6:
                    g_water = g
                    Lc = d
                else:
                    g_water = g * np.sin(theta)
                    Lc = package_length
                    
                #if the package is the one next to the start node
                if (i == 0 and start_node_name == link.start_node_packages) or (i == len(link_packages) - 1 and end_node_name == link.start_node_packages):
                    #For start node: other pipe is upstream and current pipe is downstream
                    for other_name in start_links:
                        if other_name != name:
                            other_link = wn.get_link(other_name)
                            if start_node_name == other_link.start_node_packages:
                                other_package = other_link.packages[0]
                            else:
                                other_package = other_link.packages[-1]
                            #---Conduction
                            other_d = other_link.diameter
                            other_A_cross = np.pi * other_d ** 2 / 4
                            other_volume = other_package['volume'] 
                            other_length = other_volume / other_A_cross
                            other_t = other_package['temperature']
                            other_k = get_property(other_t, 'w_k')
                            other_R = other_length / 2 / (other_k * other_A_cross)
                            R_0n = R_0 + other_R
                            b_0n = 1 / (rho_water * package_volume * cp_water * R_0n)
                            dt_a_conduction += other_t + (t_bulk - other_t) * np.e ** (-b_0n * time_step) - t_bulk
                            #---Convection
                            other_mu = get_property(other_t, 'w_mu')
                            other_rho = get_property(other_t, 'w_rho')
                            other_nu = other_mu / other_rho
                            other_flow = abs(round(flows.loc[t * time_step, other_name], 6))
                            other_v_cross = other_flow / other_A_cross
                            other_Re = other_v_cross * other_d / other_nu
                            other_beta = get_property(other_t, 'w_beta')
                            other_theta = other_link.theta
                            if other_theta < np.pi / 6:
                                other_g = g
                                other_Lc = other_d
                            else:
                                other_g = g * np.sin(other_theta)
                                other_Lc = other_length
                                
                            A_cross_conv = np.mean([A_cross, other_A_cross])
                            if flow == 0 and other_flow == 0:
                                convection = True
                            else:
                                Gr_water = g_water * beta_water * abs(t_bulk - other_t) * Lc ** 3 / nu_water ** 2
                                other_Gr = other_g * other_beta * abs(t_bulk - other_t) * other_Lc ** 3 / other_nu ** 2
                                Gr_conv = np.mean([Gr_water, other_Gr])
                                Re_conv = np.mean([Re_water, other_Re])
                                Ri_conv = Gr_conv / Re_conv ** 2
                                Ri_conv = 0 #TEST
                                if Ri_conv > 0.1:
                                    convection = True
                                else:
                                    convection = False
                                    
                            if convection: #verify positioning
                                other_high_node = other_link.high_node
                                if t_bulk > other_t: #if downstream pipe is warmer
                                    if (high_node[0] is None) or (start_node_name in high_node): #if downstream hot pipe is horizontal or going down
                                        other_high_node = other_link.high_node
                                        if start_node_name not in other_high_node: #if upstream cold pipe is going down or is horizontal
                                            convection = True
                                        else: #if upstream cold pipe is going up
                                            convection = False
                                    else: #if downstream hot pipe is going up
                                        convection = False
                                elif t_bulk < other_t: #if downstream pipe is colder
                                    if start_node_name not in high_node: #if downstream cold pipe is horizontal or going up
                                        other_high_node = other_link.high_node
                                        if (other_high_node[0] is None) or (start_node_name in other_high_node): #if upstream hot pipe is going up or is horizontal
                                            convection = True
                                        else: #if upstream hot pipe is going down
                                            convection = False
                                    else: #if downstream cold pipe is going down
                                        convection = False
                                else: #if the temperature is the same
                                    convection = False
                                    
                            #convection = False #TEST
                            if convection: #if it passed all tests, calculate convection
                                v_water = FACTOR * g_water * beta_water * Lc ** 2 * abs(t_bulk - other_t) / nu_water
                                other_v = FACTOR * other_g * other_beta* other_Lc ** 2 * abs(t_bulk - other_t) / other_nu
                                v_conv = np.min([v_water, other_v])
                                #v_conv = np.mean([v_water, other_v])
                                volume_conv = v_conv * A_cross_conv * time_step #total volume exchanged between packages
                                # if name == 'A_Cold':
                                #     print('START')
                                #     print(name + ' (' + str(theta * 180 / np.pi) + ')')
                                #     print('V=' + str(volume_conv * 10 ** 6) + 'cm3')
                                #     print('with: ' + other_name + ' (' + str(other_theta * 180 / np.pi) + ')')
                                #     print('---')
                                if volume_conv > package_volume * 2:
                                    volume_conv = package_volume * 2
                                if volume_conv > other_volume * 2:
                                    volume_conv = other_volume * 2
                                dt_a_convection += (volume_conv / 2 * other_t + (package_volume - volume_conv / 2) * t_bulk) / package_volume - t_bulk #weighted average temperature of the volume enetering the package and the volume that is left, minus the previous temperature
                
                #if the package is the one next to the end node
                if (i == 0 and end_node_name == link.start_node_packages) or (i == len(link_packages) - 1 and start_node_name == link.start_node_packages):
                    #For end node: other pipe is downstream and current pipe is upstream
                    for other_name in end_links:
                        if other_name != name:
                            other_link = wn.get_link(other_name)
                            if end_node_name == other_link.start_node_packages:
                                other_package = other_link.packages[0]
                            else:
                                other_package = other_link.packages[-1]
                            #---Conduction
                            other_d = other_link.diameter
                            other_A_cross = np.pi * other_d ** 2 / 4
                            other_volume = other_package['volume'] 
                            other_length = other_volume / other_A_cross
                            other_t = other_package['temperature']
                            other_k = get_property(other_t, 'w_k')
                            other_R = other_length / 2 / (other_k * other_A_cross)
                            R_0n = R_0 + other_R
                            b_0n = 1 / (rho_water * package_volume * cp_water * R_0n)
                            dt_a_conduction += other_t + (t_bulk - other_t) * np.e ** (-b_0n * time_step) - t_bulk
                            #---Convection
                            other_mu = get_property(other_t, 'w_mu')
                            other_rho = get_property(other_t, 'w_rho')
                            other_nu = other_mu / other_rho
                            other_flow = abs(round(flows.loc[t * time_step, other_name], 6))
                            other_v_cross = other_flow / other_A_cross
                            other_Re = other_v_cross * other_d / other_nu
                            other_beta = get_property(other_t, 'w_beta')
                            other_theta = other_link.theta
                            if other_theta < np.pi / 6:
                                other_g = g
                                other_Lc = other_d
                            else:
                                other_g = g * np.sin(other_theta)
                                other_Lc = other_length
                                
                            A_cross_conv = np.mean([A_cross, other_A_cross])
                            if flow == 0 and other_flow == 0:
                                convection = True
                            else:
                                Gr_water = g_water * beta_water * abs(t_bulk - other_t) * Lc ** 3 / nu_water ** 2
                                other_Gr = other_g * other_beta * abs(t_bulk - other_t) * other_Lc ** 3 / other_nu ** 2
                                Gr_conv = np.mean([Gr_water, other_Gr])
                                Re_conv = np.mean([Re_water, other_Re])
                                Ri_conv = Gr_conv / Re_conv ** 2
                                Ri_conv = 0 #TEST
                                if Ri_conv > 0.1:
                                    convection = True
                                else:
                                    convection = False
                            
                            if convection: #verify positioning
                                other_high_node = other_link.high_node
                                if t_bulk > other_t: #if upstream pipe is warmer
                                    if (high_node[0] is None) or (end_node_name in high_node): #if upstream hot pipe is horizontal or going up
                                        other_high_node = other_link.high_node
                                        if end_node_name not in other_high_node: #if downstream cold pipe is going up or is horizontal
                                            convection = True
                                        else: #if downstream cold pipe is going down
                                            convection = False
                                    else: #if upstream hot pipe is going down
                                        convection = False
                                elif t_bulk < other_t: #if upstream pipe is colder
                                    if end_node_name not in high_node: #if upstream cold pipe is horizontal or going down
                                        other_high_node = other_link.high_node
                                        if (other_high_node[0] is None) or (end_node_name in other_high_node): #if downstream hot pipe is going down or is horizontal
                                            convection = True
                                        else: #if downstream hot pipe is going up
                                            convection = False
                                    else: #if upstream cold pipe is going up
                                        convection = False
                                else: #if the temperature is the same
                                    convection = False
                            
                            # if name == 'A_Cold' and convection:
                            #     print('check_2')    
                            
                            #convection = False #TEST
                            if convection: #if it passed all tests, calculate convection
                                v_water = FACTOR * g_water * beta_water * Lc ** 2 * abs(t_bulk - other_t) / nu_water
                                other_v = FACTOR * other_g * other_beta * other_Lc ** 2 * abs(t_bulk - other_t) / other_nu
                                v_conv = np.min([v_water, other_v])
                                #v_conv = np.mean([v_water, other_v])
                                volume_conv = v_conv * A_cross_conv * time_step #total volume exchanged between packages
                                # if name == 'A_Cold':
                                #     print('END')
                                #     print(name + ' (' + str(theta * 180 / np.pi) + ')')
                                #     print('V=' + str(volume_conv * 10 ** 6) + 'cm3')
                                #     print('with: ' + other_name + ' (' + str(other_theta * 180 / np.pi) + ')')
                                #     print('---')
                                if volume_conv > package_volume * 2:
                                    volume_conv = package_volume * 2
                                if volume_conv > other_volume * 2:
                                    volume_conv = other_volume * 2
                                dt_a_convection += (volume_conv / 2 * other_t + (package_volume - volume_conv / 2) * t_bulk) / package_volume - t_bulk #weighted average temperature of the volume enetering the package and the volume that is left, minus the previous temperature
            
                #if the package is not the first one, take the previous one
                if i > 0:
                    other_package = link.packages[i - 1]
                    #---Conduction
                    other_volume = other_package['volume'] 
                    other_length = other_volume / A_cross
                    other_t = other_package['temperature']
                    other_k = get_property(other_t, 'w_k')
                    other_R = other_length / 2 / (other_k * A_cross)
                    R_0n = R_0 + other_R
                    b_0n = 1 / (rho_water * package_volume * cp_water * R_0n)
                    dt_a_conduction += other_t + (t_bulk - other_t) * np.e ** (-b_0n * time_step) - t_bulk
                    #---Convection
                    other_mu = get_property(other_t, 'w_mu')
                    other_rho = get_property(other_t, 'w_rho')
                    other_nu = other_mu / other_rho
                    other_Re = v_cross * d / other_nu
                    other_beta = get_property(other_t, 'w_beta')
                    other_Lc = other_length
                    other_g = g_water
                    A_cross_conv = A_cross
                    Re_conv = Re_water
                    if flow == 0:
                        convection = True
                    else:
                        Gr_water = g_water * beta_water * abs(t_bulk - other_t) * Lc ** 3 / nu_water ** 2
                        other_Gr = other_g * other_beta * abs(t_bulk - other_t) * other_Lc ** 3 / other_nu ** 2
                        Gr_conv = np.mean([Gr_water, other_Gr])
                        #Gr_conv = g_conv * beta_conv * abs(t_bulk - other_t) * Lc_conv ** 3 / nu_conv ** 2
                        Ri_conv = Gr_conv / Re_conv ** 2
                        Ri_conv = 0 #TEST
                        if Ri_conv > 0.1:
                            convection = True
                        else:
                            convection = False
                            
                    if convection: #verify positioning
                        if t_bulk > other_t: #if downstream package is warmer
                            if (high_node[0] is None) or (link.start_node_packages in high_node): #if packages arranged counting from more to less elevated or horizontal
                                convection = True
                            else:
                                convection = False
                        elif t_bulk < other_t: #if downstream package is colder
                            if high_node == link.start_node_packages in high_node: #if packages arranged counting from more to less elevated
                                convection = False
                            else:
                                convection = True
                    
                    #convection = False #TEST
                    if convection: #if it passed all tests, calculate convection
                        v_water = FACTOR * g_water * beta_water * Lc ** 2 * abs(t_bulk - other_t) / nu_water
                        other_v = FACTOR * other_g * other_beta* other_Lc ** 2 * abs(t_bulk - other_t) / other_nu
                        v_conv = np.min([v_water, other_v])
                        #v_conv = np.mean([v_water, other_v])
                        volume_conv = v_conv * A_cross_conv * time_step #total volume exchanged between packages
                        if volume_conv > package_volume * 2:
                            volume_conv = package_volume * 2
                        if volume_conv > other_volume * 2:
                            volume_conv = other_volume * 2
                        dt_a_convection += (volume_conv / 2 * other_t + (package_volume - volume_conv / 2) * t_bulk) / package_volume - t_bulk #weighted average temperature of the volume enetering the package and the volume that is left, minus the previous temperature
                        
                #if the package is not the last one, take the next one
                if i < len(link_packages) - 1:
                    other_package = link.packages[i + 1]
                    #---Conduction
                    other_volume = other_package['volume'] 
                    other_length = other_volume / A_cross
                    other_t = other_package['temperature']
                    other_k = get_property(other_t, 'w_k')
                    other_R = other_length / 2 / (other_k * A_cross)
                    R_0n = R_0 + other_R
                    b_0n = 1 / (rho_water * package_volume * cp_water * R_0n)
                    dt_a_conduction += other_t + (t_bulk - other_t) * np.e ** (-b_0n * time_step) - t_bulk
                    #---Convection
                    other_mu = get_property(other_t, 'w_mu')
                    other_rho = get_property(other_t, 'w_rho')
                    other_nu = other_mu / other_rho
                    other_Re = v_cross * d / other_nu
                    other_beta = get_property(other_t, 'w_beta')
                    other_Lc = other_length
                    other_g = g_water
                    A_cross_conv = A_cross
                    Re_conv = Re_water
                    if flow == 0:
                        convection = True
                    else:
                        Gr_water = g_water * beta_water * abs(t_bulk - other_t) * Lc ** 3 / nu_water ** 2
                        other_Gr = other_g * other_beta * abs(t_bulk - other_t) * other_Lc ** 3 / other_nu ** 2
                        Gr_conv = np.mean([Gr_water, other_Gr])
                        Ri_conv = Gr_conv / Re_conv ** 2
                        Ri_conv = 0 #TEST
                        if Ri_conv > 0.1:
                            convection = True
                        else:
                            convection = False
                            
                    if convection: #verify positioning
                        if t_bulk > other_t: #if upstream package is warmer
                            if link.start_node_packages in high_node: #if packages arranged counting from more to less elevated
                                convection = False
                            else:
                                convection = True
                        elif t_bulk < other_t: #if upstream package is colder
                            if (high_node[0] is None) or (link.start_node_packages in high_node): #if packages arranged counting from more to less elevated or horizontal
                                convection = True
                            else:
                                convection = False
                      
                    #convection = False #TEST
                    if convection: #if it passed all tests, calculate convection
                        v_water = FACTOR * g_water * beta_water * Lc ** 2 * abs(t_bulk - other_t) / nu_water
                        other_v = FACTOR * other_g * other_beta* other_Lc ** 2 * abs(t_bulk - other_t) / other_nu
                        v_conv = np.min([v_water, other_v])
                        #v_conv = np.mean([v_water, other_v])
                        volume_conv = v_conv * A_cross_conv * time_step #total volume exchanged between packages
                        if volume_conv > package_volume * 2:
                            volume_conv = package_volume * 2
                        if volume_conv > other_volume * 2:
                            volume_conv = other_volume * 2
                        dt_a_convection += (volume_conv / 2 * other_t + (package_volume - volume_conv / 2) * t_bulk) / package_volume - t_bulk #weighted average temperature of the volume enetering the package and the volume that is left, minus the previous temperature
        
            current_t = package['temperature']
            new_t = current_t + dt_r + dt_a_conduction + dt_a_convection
            heat_flow_r = (new_t - t_room) / R_overall #possitive if cooling
            t_s_in = new_t - heat_flow_r * R_water
            t_s_ex = t_s_in - heat_flow_r * R_pipe
            t_s_ex_air = t_room + heat_flow_r * R_air
            package['temperature'] = new_t
            package['temperature_s_in'] = t_s_in
            package['temperature_s_ex'] = t_s_ex
            package['temperature_s_ex_air'] = t_s_ex_air
            
            if t >= 20 * 60 and name in pipes_of_interest and i == len(link_packages) - 1:
                R_dics[name]['R_total'].append(R_overall)
                R_dics[name]['R_water'].append(R_water)
                R_dics[name]['R_pipe'].append(R_pipe)
                R_dics[name]['R_air'].append(R_air)
                R_dics[name]['heat_flow'].append(heat_flow_r)

def get_property(temperature, sheet_name):
    interpolator = interpolators[sheet_name]
    return interpolator(temperature)

def get_pipe_properties(pipe_id):
    """
    Fetches pipe properties (k, e_pipe, e_insulator, z_wall, is_insulated, has_wall) from the Pipes sheet.
    Args:
        pipe_id (str): The ID of the pipe.
        excel_file (str): Path to the Excel file.
    Returns:
        k, e_pipe, e_insulator, z_wall, is_insulated, has_wall, t_room
    """   
    
    # Ensure the ID column is treated as string for comparison
    pipe_id = str(pipe_id)
    
    # Locate the pipe row by ID
    pipe_row = pipes_df.loc[pipes_df.iloc[:, 0] == pipe_id]  # First column is treated as the ID column
    
    # Check if the pipe ID starts with 'HWH'
    if pipe_id.startswith('HWH'):
        t_room = float(pipe_row.iloc[0, 1])
        k_pipe = e_pipe = k_insulator = e_insulator = k_wall = z_wall = 0.0
        is_insulated = has_wall = False
        return t_room, k_pipe, e_pipe, k_insulator, e_insulator, k_wall, z_wall, is_insulated, has_wall
    
    if pipe_row.empty:
        raise ValueError(f"Pipe ID '{pipe_id}' not found in the Pipes sheet.")
    
    # Extract properties by column index (1-based in Excel):
    t_room = float(pipe_row.iloc[0, 1])
    k_pipe = float(pipe_row.iloc[0, 2])
    e_pipe = float(pipe_row.iloc[0, 3]) / 1000
    k_insulator = pipe_row.iloc[0, 4] if pd.notna(pipe_row.iloc[0, 4]) else 0  
    e_insulator = (pipe_row.iloc[0, 5] / 1000) if pd.notna(pipe_row.iloc[0, 5]) else 0
    k_wall = pipe_row.iloc[0, 6] if pd.notna(pipe_row.iloc[0, 6]) else 0 
    z_wall = pipe_row.iloc[0, 7] / 1000 if pd.notna(pipe_row.iloc[0, 7]) else 0  
     # Sixth column
    
    # Booleans for insulation and wall
    is_insulated = e_insulator > 0
    has_wall = z_wall > 0
    
    # Return the tuple
    return t_room, k_pipe, e_pipe, k_insulator, e_insulator, k_wall, z_wall, is_insulated, has_wall
 
def get_Nusselt_natural(Gr, Pr):
    Ra = Gr * Pr
    if Ra >= 4.545 * 10 ** 9: #turbulent natural convection
        C = 0.021
        m = 0.4
    elif Ra >= 10 ** 4:
        C = 0.59
        m = 0.25
    else: #if Ra below range, use lowest Ra number (TODO: Try treating as a solid, which is the other option)
        Ra = 10 ** 4
        C = 0.59
        m = 0.25
    Nusselt = C * Ra ** m
    return Nusselt
    
def get_Nusselt_forced(Re, Pr, d, L, cooling):
    if Re < 10000: #for laminar flow
        Nusselt = 3.66 + 0.065 * Re * Pr * d / L / (1 + 0.04 * (Re * Pr * d / L) ** (2 / 3))
    else: #Dittus-Boelter equation #TODO improve with f in equation from Cengel
        C = 0.023
        m = 4 / 5
        if cooling:
            n = 1 / 3
        else:
            n = 2 / 5
        Nusselt = C * Re ** m * Pr ** n
    return Nusselt

def get_R(pipe, package, flow):
    
    t_room = pipe.temperature_infinity
    t_bulk = package['temperature']
    t_s_in = package['temperature_s_in']
    t_s_ex_air = package['temperature_s_ex_air']
    
    d1 = pipe.diameter
    A_cross = np.pi * d1 ** 2 / 4
    vel = flow / A_cross
    
    P1 = np.pi * d1
    L_package = package['volume'] / A_cross
    A1 = L_package * P1
    
    theta_pipe = pipe.theta
    
    epsilon_pipe = pipe.e_link
    d2 = d1 + 2 * epsilon_pipe
    k_pipe = pipe.k_pipe
    
    has_insulator = pipe.insulator
    epsilon_insulator = pipe.e_insulator
    k_insulator = pipe.k_insulator
    
    z_wall = pipe.z_wall
    k_wall = pipe.k_wall
    
    heat_flow = 0
    err = np.inf
    
    iter = 0
    finished = False
    
    while (err > 0.01) and (not finished):
        
        t_film_water = (t_bulk * t_s_in) ** 0.5
        t_film_air = (t_room + t_s_ex_air) / 2
        if t_bulk > t_room:
            is_cooling = True
        else:
            is_cooling = False
    
        mu_water = get_property(t_film_water, 'w_mu')
        rho_water = get_property(t_film_water, 'w_rho')
        beta_water = get_property(t_film_water, 'w_beta')
        cp_water = get_property(t_film_water, 'w_cp')
        k_water = get_property(t_film_water, 'w_k')
        nu_water = mu_water / rho_water
        Pr_water = mu_water * cp_water / k_water
        
        mu_air = get_property(t_film_air, 'a_mu')
        rho_air = get_property(t_film_air, 'a_rho')
        beta_air = 1 / (t_film_air + 273.15)
        cp_air = get_property(t_film_air, 'a_cp')
        k_air = get_property(t_film_air, 'a_k')
        nu_air = mu_air / rho_air
        Pr_air = mu_air * cp_air / k_air
        
        Re = vel * d1 / nu_water
        
        if theta_pipe < np.pi / 6:
            Lc = d1
            Gr_water = g * beta_water * abs(t_bulk - t_s_in) * Lc ** 3 / nu_water ** 2
        else:
            Lc = L_package
            Gr_water = g * np.sin(theta_pipe) * beta_water * abs(t_bulk - t_s_in) * Lc ** 3 / nu_water ** 2
         
        h_water_forced = 0
        h_water_natural = 0
        if Re > 0:
            Ri = Gr_water / Re ** 2
            if Ri > 0.1:
                Nusselt_natural = get_Nusselt_natural(Gr_water, Pr_water)
                h_water_natural = Nusselt_natural * k_water / Lc
            if Ri < 10:
                Nusselt_forced = get_Nusselt_forced(Re, Pr_water, d1, L_package, is_cooling)
                h_water_forced = Nusselt_forced * k_water / Lc
        else:
            Nusselt_natural = get_Nusselt_natural(Gr_water, Pr_water)
            h_water_natural = Nusselt_natural * k_water / Lc
        h_water_convection = h_water_forced + h_water_natural
        
        if h_water_convection == 0:
            h_water_convection = 1e-10  # A very small positive value
    
        R_water = 1 / (h_water_convection * A1) #Contribution of water to radial heat transfer resistance
        
        R_pipe = np.log(d2 / d1) / (2 * np.pi * L_package * k_pipe)
        
        if has_insulator:
            d3 = d2 + 2 * epsilon_insulator
            R_insulator = np.log(d3 / d2) / (2 * np.pi * L_package * k_insulator)
        else:
            d3 = d2
            R_insulator = 0
        P3 = np.pi * d3
        A3 = L_package * P3
        if pipe.wall:
            R_air = 0
            S_wall = 2 * np.pi * L_package / np.log(8 * z_wall / (np.pi * d3))
            R_wall = 1 / (k_wall * S_wall)
        else:
            R_wall = 0
            if theta_pipe < np.pi / 6:
                Lc_air = d3
                Gr_air = g * beta_air * abs(t_s_ex_air - t_room) * Lc_air ** 3 / nu_air ** 2
                Ra_air = Gr_air * Pr_air
                Nusselt_air = (0.6 + 0.387 * Ra_air ** (1 / 6) / (1 + (0.559 / Pr_air) ** (9 / 16)) ** (8 / 27)) ** 2
            else:
                Lc_air = L_package
                Gr_air = g * np.sin(theta_pipe) * beta_air * abs(t_s_ex_air - t_room) * Lc_air ** 3 / nu_air ** 2
                Ra_air = Gr_air * Pr_air
                if Ra_air < 10 ** 9: #Laminar convective flow
                    Nusselt_lp = 0.68 + 0.67 * Ra_air ** (1 / 4) / (1 + (0.492 / Pr_air) ** (9 / 16)) ** (4 / 9)
                else: #Non-laminar convective flow
                    Nusselt_lp = (0.825 + 0.387 * Ra_air ** (1 / 6) / (1 + (0.492 / Pr_air) ** (9 / 16)) ** (8 / 27)) ** 2
                eps = 1e-10  # A very small positive value
                Gr_air = max(Gr_air, eps)  # Prevent Gr_air from being <= 0
                Nusselt_air = Nusselt_lp * (1 + 0.3 * (32 ** 0.5 * Gr_air ** (-0.25) * L_package / d3) ** 0.909)
            h_air = k_air / Lc_air * Nusselt_air
            R_air = 1 / (h_air * A3)
        
        R_overall = R_water + R_pipe + R_insulator + R_wall + R_air #TODO
        
        new_heat_flow = (t_bulk - t_room) / R_overall #possitive if cooling
        past_err = err
        err = abs(heat_flow - new_heat_flow)
        if (err >= past_err) or (iter >= 10):
            finished = True
        iter += 1
        heat_flow = new_heat_flow
        t_s_in = t_bulk - heat_flow * R_water
        t_s_ex = t_s_in - heat_flow * R_pipe
        t_s_ex_air = t_s_ex - heat_flow * R_insulator
    
    return R_overall, R_water, R_pipe, R_insulator, R_wall, R_air

def get_rgb(temp):
    min_temp = cold_water
    max_temp = hot_water
    inf_temp = 25
    
    if temp < min_temp:
        red = 0
        green = 0
        blue = 255
    elif temp > max_temp:
        red = 255
        green = 0
        blue = 0
    elif temp <= inf_temp:
        red = int(round(255 / 2 * (temp - min_temp) / (inf_temp - min_temp), 0))
        #red = int(round(255 * (temp - min_temp) / (max_temp - min_temp), 0))
        green = 0
        blue = 255 - red
    else:
        blue = int(round(255 / 2 * (max_temp - temp) / (max_temp - inf_temp), 0))
        green = 0
        red = 255 - blue
    rgb = 'rgb(' + str(red) + ',' + str(green) + ',' + str(blue) + ')'
    return rgb

def get_slider_intervals(time_chosen, time_interval, total_time, t_step):
    if time_interval == 'Bi-hourly':
        delta_t = 2 * 3600
        #step = 5 #TODO
        step = t_step
        lab = ' 2 hours'
    elif time_interval == 'Daily':
        delta_t = 24 * 3600
        step = 60
        lab = ' day'
    elif time_interval == 'Weekly':
        delta_t = 168 * 3600
        step = 300
        lab = ' week'
    start = int(np.floor(time_chosen / delta_t)) * delta_t
    if start + delta_t > total_time:
        end = total_time
    else:
        end = start + delta_t
    if start == 0:
        hide_prev = True
    else:
        hide_prev = False
    if end == total_time:
        hide_next = True
    else:
        hide_next = False
    prev_label = 'Previous' + lab
    next_label = 'Next' + lab
    return start, end, step, prev_label, next_label, hide_prev, hide_next, delta_t

def clic_prev_next(start, end, step, time_chosen, total_time, btn_pressed):
    if btn_pressed == 'previous':
        start = max(start - step, 0)
        time_chosen = max(time_chosen - step, 0)
        end = end - step
    elif btn_pressed == 'next':
        start = start + step
        time_chosen = min(time_chosen + step, total_time)
        end = min(end + step, total_time)
    if start == 0:
        hide_prev = True
    else:
        hide_prev = False
    if end == total_time:
        hide_next = True
    else:
        hide_next = False
    return start, end, time_chosen, hide_next, hide_prev

def on_select_element(element):
    if element == 'Link':
        options_variable = variable_options_links
        options_list = link_options
        options_list_default = link_default
    elif element == 'Node':
        options_variable = variable_options_nodes
        options_list = appliance_options
        options_list_default = appliance_default
    options_variable_default = variable_default
    return options_variable, options_list, options_variable_default, options_list_default
   
"""
START #TODO
"""
# Create a water network model
inp_file = 'Cu_fixed_6.inp'

# my_appliances = [{'name':'DW', 'type':'Dishwasher'},
#                 {'name':'WA', 'type':'EndUse'},
#                 {'name':'F3', 'type':'BathroomTap'},
#                 {'name':'SH2', 'type':'FancyShower'},
#                 {'name':'TOL1', 'type':'WcNormalSave'}]
my_appliances = [{'name':'A', 'type':'FancyShower', 'type2':'Shower'},
                 {'name':'B', 'type':'FancyShower', 'type2':'Shower'},
                {'name':'C', 'type':'FancyShower', 'type2':'Shower'},
                 ]
#TEST
pipes_of_interest = ['A_Hot']
R_dics = {}
for pipe_name in pipes_of_interest:
    R_dics[pipe_name] = {'R_total':[], 'R_water':[], 'R_pipe':[], 'R_air':[], 'heat_flow':[]}
#R_dics= {'A_Hot': {'R_total':[], 'R_water':[], 'R_pipe':[], 'R_air':[], 'heat_flow':[]}, 'A':{'R_total':[], 'R_water':[], 'R_pipe':[], 'R_air':[], 'heat_flow':[]}}
#TEST

number_of_people = 4
random_patterns = False
if not random_patterns:
    number_of_simulations = 1
    house = None
else:
    number_of_simulations = 100
    obj_appliances = get_appliances(my_appliances)
    my_users = []
    house = pysimdeum.built_house(house_type='one_person')
    base_user_male = house.users[0]
    base_user_male.gender = 'male'
    my_users.append(base_user_male)
    for i in range(number_of_people - 1):
        new_user = copy(base_user_male)
        new_user.id = 'user_' + str(i+2)
        my_users = my_users + [new_user]
    house = pysimdeum.built_house(house_type='family')
    house.appliances = obj_appliances
    house.users = []
    house.users = my_users

F1 = 1.119
F2 = -7
FACTOR = F1 * 10 ** F2 #Axial mixing convection velocity factor

cold_water = 12
hot_water = 60 #it is now taken from network_properties.xlsx

low_interval_temp = 20
high_interval_temp = 30

#room_temp = 21.5
#desired_temp = hot_water
#desired_temp = cold_water
desired_temp = 38

duration = 2 * 3600 #seconds
time_step = 1 #seconds

pipe_spreadsheet = 'network_properties.xlsx'
water_air_spreadsheet = 'water_air_properties.xlsx'

physical_property_tables = pd.read_excel(water_air_spreadsheet, sheet_name = None) #Load the Excel file with all the sheets
# Precompute interpolators for all sheets
interpolators = {}
for sheet_name, data in physical_property_tables.items():
    temperatures = data.iloc[:, 0].values  # First column as temperatures
    values = data.iloc[:, 1].values       # Second column as property values
    # Precompute the interpolator and store it
    interpolators[sheet_name] = interp1d(
        temperatures, values, kind='linear', bounds_error=False, fill_value=(values[0], values[-1])
    )
# Read the Pipes sheet
pipes_df = pd.read_excel(pipe_spreadsheet, sheet_name="Pipes")
pipes_df.iloc[:, 0] = pipes_df.iloc[:, 0].astype(str)

#legend_1 = 'Lowest total demand'
#legend_2 = 'Highest total demand'
#legend_3 = 'Lowest peak age'
#legend_4 = 'Highest peak age'
legend_1 = 'Highest PWA'
#legend_2 = 'Lowest PWA'
# legend_3 = 'Highest PTI'
# legend_4 = 'Lowest PTI'

results_dic = [{'name': 'max_age', 'legend': legend_1, 'show2': True,'value': 0, 'coordinates': {'pipe': None, 'time': None},'results': None},
               #{'name': 'min_age', 'legend': legend_2, 'show2': True, 'value': float('inf'), 'coordinates': {'pipe': None, 'time': None}, 'results': None},
               # {'name': 'max_PTI', 'legend': legend_3, 'show2': True, 'value': 0, 'results': None},
               # {'name': 'min_PTI', 'legend': legend_4, 'show2': True, 'value': float('inf'), 'results': None}
               ]

mark_dic = get_plot_time_marks(duration)

element_options = ['Link', 'Node']
element_default = 'Link'
cti_option_text = 'Consecutive Time Between ' + str(low_interval_temp) + '°C and ' + str(high_interval_temp) + '°C'
variable_options_links = ['Age', 'Temperature', cti_option_text]
variable_options_nodes = ['Age', 'Demand']
variable_default = 'Age'
simulation_options = [legend_1] #legend_2]#, legend_3, legend_4]
time_options = ['Weekly', 'Daily', 'Bi-hourly']
simulation_default = legend_1
time_default = 'Weekly'
demand_units = 'L/min'
age_units = 'hours'

for i in tqdm(range(number_of_simulations)):
    sleep(0.0001)
    
    wn = wntr.network.WaterNetworkModel(inp_file)
    wn.options.quality.parameter = 'AGE'

    wn.options.time.hydraulic_timestep = time_step
    wn.options.time.quality_timestep = time_step
    wn.options.time.pattern_timestep =  time_step
    wn.options.time.report_timestep = time_step
    wn.options.time.pattern_start = 0

    wn.options.time.duration = duration
    
    plot_links = list(wn.links.keys())
    
    for name, control in wn.controls():
        wn.remove_control(name)
        
    g = 9.81 #gravity
    
    # if random_patterns:
    #     for junction_name, junction in wn.junctions():
    #         junction.demand_timeseries_list.clear()
    #    wn.patterns.clear()
    pattern_list = generate_weekly_patterns(my_appliances, house, random_patterns)
    #-------------------------------------------------------------Asign patterns
    plot_nodes = []
    for appliance in my_appliances:
        appliance_name = appliance['name']
        appliance_pattern = pattern_list[appliance_name]
        pattern = []
        time = 0
        valve_cold_name = 'VC_' + appliance_name
        valve_hot_name = 'VH_' + appliance_name
        setting_multiplier_cold = (hot_water - desired_temp) / (hot_water - cold_water)
        setting_multiplier_hot = 1 - setting_multiplier_cold
        try:
            valve_cold = wn.get_link(valve_cold_name)
        except:
            valve_cold = None
            print('Valve ' + valve_cold_name + ' not found.')
        try:
            valve_hot = wn.get_link(valve_hot_name)
        except:
            valve_hot = None
            print('Valve ' + valve_hot_name + ' not found.')
        # if valve_cold == None:
        #     while time < duration:
        #         day = int(np.floor(time / 86400))
        #         second = time - day * 86400
        #         if random_patterns:
        #             multiplier = appliance_pattern[second, day] / 1000
        #         else:
        #             multiplier = appliance_pattern[0, int(time / time_step - 1)]
        #         pattern.append(multiplier)
        #         time = time + time_step
        # else:
        past_multiplier = 0
        while time < duration:
            day = int(np.floor(time / 86400))
            second = time - day * 86400
            if random_patterns:
                multiplier = appliance_pattern[second, day] / 1000
            else:
                multiplier = appliance_pattern[0, int(time / time_step - 1)]
            pattern.append(multiplier)
            if multiplier != past_multiplier:
                setting_cold = setting_multiplier_cold * multiplier
                setting_hot = setting_multiplier_hot * multiplier
                act_cold = controls.ControlAction(valve_cold, 'setting', setting_cold)
                act_hot = controls.ControlAction(valve_hot, 'setting', setting_hot)
                clock_time = seconds_to_clock(time, False)
                cond = controls.SimTimeCondition(wn, '=', clock_time)
                ctrl_name_cold = valve_cold_name + clock_time
                ctrl_name_hot = valve_hot_name + clock_time
                ctrl_cold = controls.Control(cond, act_cold, name=ctrl_name_cold)
                ctrl_hot = controls.Control(cond, act_hot, name=ctrl_name_hot)
                try:
                    wn.add_control(ctrl_name_cold, ctrl_cold)
                    wn.add_control(ctrl_name_hot, ctrl_hot)
                except:
                    wn.remove_control(ctrl_name_cold)
                    wn.remove_control(ctrl_name_hot)
                    wn.add_control(ctrl_name_cold, ctrl_cold)
                    wn.add_control(ctrl_name_hot, ctrl_hot)
                    
            past_multiplier = multiplier
            time = time + time_step
        plot_nodes.append(appliance_name)
        if random_patterns:
            wn.add_pattern(appliance_name, pattern)
            demand_node = wn.get_node(appliance_name)
            base_1 = 1
            demand_node.demand_timeseries_list.clear()
            my_category = 'pysimdeum'
            demand_node.add_demand(base = base_1, pattern_name = appliance_name, category = my_category)
    
    sim = wntr.sim.EpanetSimulator(wn)
    results = sim.run_sim()
    
    data = get_network_data(wn)
    demands = results.node['demand']
    #node_ages = results.node['quality']
    link_ages = results.link['quality']
    
    try:
        plot_tanks = wn.tank_name_list
    except:
        plot_tanks = []
    
    plot_nodes_plus_tanks = plot_nodes + plot_tanks
    
    #plot_ages = node_ages.loc[:, plot_nodes_plus_tanks].sum(axis = 1)
    plot_ages = link_ages.sum(axis = 1)
    #max_age = max(plot_ages)
    
    max_age = link_ages.max().max()
    
    total_demand = demands.loc[:,plot_nodes].sum(axis = 1).sum(axis = 0)
    
    for result in results_dic:
        name = result['name']
        value = result['value']
        coordinates = result['coordinates']
        
        if (max_age > value) and (name == 'max_age'):
            max_age_time = link_ages.max(axis=1).idxmax()
            max_age_pipe = link_ages.max(axis=0).idxmax()
            result['value'] = max_age
            result['coordinates']['pipe'] = max_age_pipe
            result['coordinates']['time'] = seconds_to_clock(max_age_time, True)
            result['results'] = copy(results)

        if (max_age < value) and (name == 'min_age'):
            max_age_time = link_ages.max(axis=1).idxmax()
            max_age_pipe = link_ages.max(axis=0).idxmax()
            result['value'] = max_age
            result['coordinates']['pipe'] = max_age_pipe
            result['coordinates']['time'] = seconds_to_clock(max_age_time, True)
            result['results'] = copy(results)
        
        # if (total_demand > value) and (name == 'max_demand'):
        #     result['value'] = total_demand
        #     result['results'] = copy(results)
            
        # if (total_demand < value) and (name == 'min_demand'):
        #     result['value'] = total_demand
        #     result['results'] = copy(results)
       
results_dic = get_temp_dics(results_dic, data)

link_options = plot_links
link_default = plot_links[0]
appliance_options = ['SUM OF ALL'] + plot_nodes_plus_tanks #+ plot_links
appliance_default = 'SUM OF ALL'

# Initialize the app
app = Dash(__name__)
app.title = 'Test Network'
colors = {
    'text': '#7FDBFF'
}

# App layout
app.layout = html.Div(children=[
    html.Div('Show results of:', style={'color': 'darkblue', 'fontSize': 14}),
    dcc.RadioItems(variable_options_nodes, variable_default, inline=True, id='radio_variable_1' ),
    html.Div('For the simulation (out of ' + str(number_of_simulations) + ' random simulations with ' + str(number_of_people) + ' people) with:', style={'color': 'darkblue', 'fontSize': 14}),
    dcc.RadioItems(simulation_options, simulation_default, inline=True, id='radio_simulation_1'),
    dcc.Graph(figure={}, id='my-network', config={'displayModeBar': False}),
    dcc.RadioItems(time_options, time_default, inline=True, id='radio_time_1'),
    html.Button('Previous', id='btn-previous', n_clicks=0),
    html.Button('Next', id='btn-next', n_clicks=0),
    html.Div(id='slider-value-text', style={'font-size': 30, 'color':'lime', 'text-align': 'center'}),
    dcc.Slider(0, duration, 300,
               value=0, marks=mark_dic,
               id='my-slider'
    ),
    dcc.Graph(figure={}, id='my-graph', config={'displayModeBar': False}),
    html.Div('Show results for:', style={'color': 'darkblue', 'fontSize': 14}),
    dcc.RadioItems(element_options, element_default, inline=True, id='radio_element_2'),
    html.Div('Variable:', style={'color': 'darkblue', 'fontSize': 14}),
    dcc.RadioItems(variable_options_links, variable_default, inline=True, id='radio_variable_2'),
    html.Div('For the simulation(s) (out of ' + str(number_of_simulations) + ' random simulations with ' + str(number_of_people) + ' people) with:', style={'color': 'darkblue', 'fontSize': 14}),
    dcc.Checklist(simulation_options, simulation_options, inline=True, id='check_simulation_2'),
    html.Div('Select Object:', style={'color': 'darkblue', 'fontSize': 14}),
    dcc.RadioItems(link_options, link_default, inline=False, id='radio_selection_2'),
    
])

# Add controls to build the interaction
@callback(
    Output(component_id='my-network', component_property='figure'),
    Output(component_id='my-graph', component_property='figure'),
    Output('slider-value-text', 'children'),
    Output(component_id='my-slider', component_property='value'),
    Output(component_id='my-slider', component_property='min'),
    Output(component_id='my-slider', component_property='max'),
    Output(component_id='my-slider', component_property='step'),
    Output('btn-previous', component_property='children'),
    Output('btn-next', component_property='children'),
    Output('btn-previous', component_property='hidden'),
    Output('btn-next', component_property='hidden'),
    #Output('radio_variable_2', component_property='options'),
    #Output('radio_selection_2', component_property='options'),
    #Output('radio_variable_2', component_property='value'),
    #Output('radio_selection_2', component_property='value'),
    #Output(component_id='my-slider', component_property='marks'),
    Input(component_id='my-slider', component_property='value'),
    Input(component_id='radio_variable_1', component_property='value'),
    Input(component_id='radio_simulation_1', component_property='value'),
    Input(component_id='radio_time_1', component_property='value'),
    Input(component_id='radio_element_2', component_property='value'),
    Input(component_id='radio_variable_2', component_property='value'),
    Input(component_id='check_simulation_2', component_property='value'),
    Input(component_id='radio_selection_2', component_property='value'),
    Input('btn-previous', 'n_clicks'),
    Input('btn-next', 'n_clicks')
)
def update_app(time_chosen, variable_1, simulation_1, time_interval, element_2, variable_2, simulation_2, selection_2, btn_prev, btn_next):
    
    t = time_chosen
    #[variable2_options, selection2_options, variable2_default, selection2_default] = on_select_element(element_2)
    my_options = {'elem_to_plot_2': element_2, 'var_to_plot_1': variable_1, 'var_to_plot_2': variable_2, 'sim_to_plot_1': simulation_1, 'sim_to_plot_2': simulation_2, 'obj_to_plot_2':selection_2}
    [network_fig, graph_fig] = draw_network_fig(data, results_dic, t, my_options)
    [start, end, step, prev_label, next_label, hide_prev, hide_next, delta_t] = get_slider_intervals(time_chosen, time_interval, duration, time_step)
    if "btn-previous" == ctx.triggered_id:
        [start, end, time_chosen, hide_next, hide_prev] = clic_prev_next(start, end, delta_t, time_chosen, duration, 'previous')
    elif "btn-next" == ctx.triggered_id:
        [start, end, time_chosen, hide_next, hide_prev] = clic_prev_next(start, end, delta_t, time_chosen, duration, 'next')
    #marks = get_plot_time_marks(end-start)
    
    slider_text = 'Showing results of ' + variable_1.lower() + ' at time {}'.format(seconds_to_clock(time_chosen, True)) + ' for the simulation with ' + simulation_1.lower()
    
    return network_fig, graph_fig, slider_text, time_chosen, start, end, step, prev_label, next_label, hide_prev, hide_next, #variable2_options, selection2_options, variable2_default, selection2_default#, marks

@app.callback(
    [Output('radio_variable_2', component_property='options'),
    Output('radio_variable_2', component_property='value')],
    [Input(component_id='radio_element_2', component_property='value')]
)
def update_variable_2_options(element_type):
    new_var_options = []
    if element_type == 'Link':
        new_var_options = variable_options_links
    elif element_type == 'Node':
        new_var_options = variable_options_nodes
    new_var_default = variable_default
    return new_var_options, new_var_default

@app.callback(
    [Output('radio_selection_2', component_property='options'),
    Output('radio_selection_2', component_property='value')],
    [Input(component_id='radio_element_2', component_property='value')]
)
def update_selected_2_options(element_type):
    new_sel_options = []
    if element_type == 'Link':
        new_sel_options = link_options
        new_sel_default = link_default
    elif element_type == 'Node':
        new_sel_options = appliance_options
        new_sel_default = appliance_default
    return new_sel_options, new_sel_default

# Run the app
if __name__ == '__main__':
    app.run(debug=False)

webbrowser.open('http://127.0.0.1:8050/')

varz1 = result['temperatures']['links']
keys_to_extract = ['A_Cold', 'A_Hot', 'A', 'B_Cold', 'B_Hot', 'B', 'C_Cold', 'C_Hot', 'C']
varz2 = [{key: d[key] for key in keys_to_extract} for d in varz1]
df1 = pd.DataFrame(varz2)
# varz1_s_ex = result['temperatures']['links_s_ex']
# varz2_s_ex = [{key: d[key] for key in keys_to_extract} for d in varz1_s_ex]
# df2 = pd.DataFrame(varz2_s_ex)
# Concatenate the two DataFrames column-wise
# df_combined = pd.concat([df1, df2], axis=1)
output_file = str(F1) + 'x10^' + str(F2) + '_T=' + str(desired_temp) + '.xlsx'
#output_file = 'NO_AXIAL.xlsx'
#df1.to_excel(output_file, index=False)
#df_combined.to_excel(output_file, index=False)
with pd.ExcelWriter(output_file, engine='xlsxwriter') as writer:
    # Write the first dataframe to a sheet
    df1.to_excel(writer, sheet_name='Temperatures', index=False)
    # Write R_dics data to separate sheets
    for sheet_name, R_list in R_dics.items():
        # Convert the dictionary to a DataFrame
        df_r = pd.DataFrame(R_list)
        # Write the DataFrame to the sheet
        df_r.to_excel(writer, sheet_name=sheet_name, index=False)